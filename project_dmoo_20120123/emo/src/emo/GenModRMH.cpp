/*! \file	GenModHybridRM.cpp
	
	\brief	Hybrid RM-MEDA
	
	\author Aimin ZHOU
	\author Department of Computer Science,
	\author University of Essex, 
	\author Colchester, CO4 3SQ, U.K
	\author azhou@essex.ac.uk
	
	\date	Jun.25 2007 design
*/

#include <algorithm>
#include <list>
#include <vector>
#include <cmath>
#include <fstream>
#include <float.h>
#include <numeric>
#include "alg/HCSampler.h"
#include "emo/GenMod.h"
#include "emo/LogFile.h"
#include "emo/Sel.h"

#if defined(WIN32)
    #define wxFinite(n) _finite(n)
#elif defined(_LINUX)
    #define wxFinite(n) finite(n)
#else
    #define wxFinite(n) ((n)==(n))
#endif

namespace az
{
namespace mea
{
namespace gen
{
namespace mod
{

//set parameters
void HybridRM::Set(double extension, double threshold, unsigned int maxgen, unsigned int minmodel, unsigned int maxmodel, unsigned int type)
{
	mExtension	= extension;
	mMaxGen		= maxgen;
	mMinM		= minmodel;
	mMaxM		= maxmodel;
	mGen		= 0;
	mHybStr		= type;

	gERM.Set(extension, threshold, minmodel, maxmodel,10);

	LogFile log('C');
}

//model-based generator
CPopulationMO& HybridRM::Generate(unsigned int sizenew, CPopulationMO& popnew, CPopulationMO& popref)
{
	double ll;

	popnew.Resize(sizenew);

	mNoNew = popnew.Size();
	//mNoM = 5 + (unsigned int)(mGen*(mMaxM-5.0)/(mMaxGen+0.0));
	mNoM = mMinM + ((mGen+1) % 2)*(mMaxM-mMinM);
	if(mNoM>mMaxM) mNoM = mMaxM;

	if(mNoNew<1) return popnew;

	// Strategy 0
	if(mHybStr == 0)
	{
		unsigned int sr,ser;
		sr = (unsigned int)(mNoNew*0.5);
		ser= mNoNew - sr;
		
		CPopulationMO popr(popnew.P()), poper(popnew.P());
		popr.Resize(sr); poper.Resize(ser);

		gERM.Generate(ser, poper, popref);

		gRM.Set(1, mNoM, 30, mExtension);
		gRM.Generate(sr, popr, popref);

		popnew.Clear();
		popnew.Combine(popr);
		popnew.Combine(poper);
	}
	// Strategy 1
	else if(mHybStr == 1)
	{
		if(mGen < 0.8*mMaxGen)
		{	
			gERM.Generate(sizenew, popnew, popref);
		}
		else
		{
			gRM.Set(1, mNoM, 30, mExtension);
			gRM.Generate(sizenew, popnew, popref);
		}
	}
	// Strategy 2
	else if(mHybStr == 2)
	{
		unsigned int i,sr,ser;
		double p;
		p = 0.0;
		for(i=0; i<popref.Size(); i++) p += (popref[i].ID() == 0) ? 1.0:0.0;
		p = 0.1 + 0.8*p/(double)(popref.Size());	// at least 10% and at most 90%, is generated by RM 
		sr = (unsigned int)(mNoNew*p);
		if(sr<3*mNoM) sr = 3*mNoM;
		ser= mNoNew - sr;
		
		CPopulationMO popr(popnew.P()), poper(popnew.P());
		popr.Resize(sr); poper.Resize(ser);

		gERM.Generate(ser, poper, popref);
		for(i=0; i<poper.Size(); i++) poper[i].ID(1);

		gRM.Set(1, mNoM, 30, mExtension);
		gRM.Generate(sr, popr, popref);
		for(i=0; i<popr.Size(); i++) popr[i].ID(0);

		popnew.Clear();
		popnew.Combine(popr);
		popnew.Combine(poper);

		ll = p;
	}
	else if(mHybStr == 3)
	{
		if(rnd::rand()<0.8)
		{	
			gERM.Generate(sizenew, popnew, popref);
			
			ll = 1;
		}
		else
		{
			CPopulationMO pop(popnew.P());
			pop.Resize(0);
			gERM.Generate(0, pop, popref);

			gRM.Set(1, mNoM, 30, mExtension);
			gRM.Generate(sizenew, popnew, popref);
			
			ll = 0;
		}
	}
	else if(mHybStr == 4)
	{
		unsigned int i;
		double p;
		p = 0.0;
		for(i=0; i<popref.Size(); i++) p += (popref[i].ID() == 0) ? 1.0:0.0;
		p = 0.1 + 0.8*p/(double)(popref.Size());	// at least 10% and at most 90%, is generated by RM 
		
		if(rnd::rand()<p)
		{
			CPopulationMO pop(popnew.P());
			pop.Resize(0);
			gERM.Generate(0, pop, popref);

			gRM.Set(1, mNoM, 30, mExtension);
			gRM.Generate(sizenew, popnew, popref);
			for(i=0; i<popnew.Size(); i++) popnew[i].ID(0);
			
			ll = 0;
		}
		else
		{
			gERM.Generate(sizenew, popnew, popref);
			for(i=0; i<popnew.Size(); i++) popnew[i].ID(1);
			
			ll = 1;
		}
	}
	
	//LogFile log;
	//log<<ll<<" ";
	//std::cout<<mGen<<std::endl;

	mGen++;
	return popnew;
}

} //namespace mod
} //namespace gen
} //namespace mea
} //namespace az
